import { FilePatchType, FileType } from './FileType';
import { findLastIndex } from '../util/array';

export type IgnoreCategories = 'build' | 'cache' | 'log' | 'external' | 'generated' | 'other';

/** Key is pattern, value is category key. */
export type IgnorePatterns = Record<string, IgnoreCategories>;

const ignoreCategories: Record<
  IgnoreCategories,
  { heading: string; description: string[]; patterns?: string[] }
> = {
  build: {
    heading: 'Build Files',
    description: [
      'Files which are the result of transforming other files in the project',
      'First item should be the path to the Typescript build output directory without any glob patterns',
    ],
  },
  cache: {
    heading: 'Cache Files',
    description: ['Generated by tools for caching'],
  },
  log: {
    heading: 'Log Files',
    description: ['Log output files intended to be read by people rather than the project'],
  },
  external: {
    heading: 'External Files',
    description: ['Files commonly created by the OS or tools not defined in this project'],
    patterns: ['.DS_Store'],
  },
  generated: {
    heading: 'Generated Files',
    description: ['Files generated by tools from the project'],
  },
  other: {
    heading: 'Other Files',
    description: ['Any other ignored files'],
  },
};

export const ignoreFileHeaderPattern = /^\s*#\s+===\s+(.+)\s+===\s*$/;
export const getIgnoreHeaderFromLine = (line: string) => {
  const match = ignoreFileHeaderPattern.exec(line);
  if (match && match[1]) {
    const entry = Object.entries(ignoreCategories).find(
      ([_key, { heading }]) => heading.toUpperCase() === match[1],
    );
    if (entry) return entry[0] as IgnoreCategories;
  }
  return undefined;
};

const getDefaultData = () => {
  const data: IgnorePatterns = {};
  for (const [categoryKey, { patterns = [] }] of Object.entries(ignoreCategories)) {
    for (const pattern of patterns) {
      data[pattern] = categoryKey as IgnoreCategories;
    }
  }
  return data;
};

export const fileTypeIgnoreFile = new FileType<IgnorePatterns, string>({
  name: 'Ignore File',
  deserialize: contents =>
    contents.split('\n').reduce<{ header: IgnoreCategories; patterns: IgnorePatterns }>(
      (state, lineRaw) => {
        const line = lineRaw.trim();
        const header = getIgnoreHeaderFromLine(line);
        if (header) {
          state.header = header;
        } else if (line.length > 0 && !line.startsWith('#')) {
          state.patterns[line] = state.header;
        }
        return state;
      },
      { header: 'other', patterns: {} },
    ).patterns,
  patch: (data = getDefaultData(), patch) => {
    if (!Array.isArray(patch)) {
      for (const [pattern, subpatch] of Object.entries(patch)) {
        if (Array.isArray(subpatch)) {
          if (subpatch[0] === FilePatchType.SET) {
            data[pattern] = subpatch[1] as IgnoreCategories;
          } else if (subpatch[0] === FilePatchType.DELETE) {
            delete data[pattern];
          }
        }
      }
    }
    return data;
  },
  serialize: (data, contents) => {
    if (contents === undefined) {
      return `# DO NOT CHANGE THE STRUCTURE OF THIS FILE
# You may add extra patterns but do not change the "=== HEADING ===" comments or provided patterns
      
${Object.entries(ignoreCategories)
  .map(
    ([key, { heading, description, patterns = [] }]) => `# === ${heading.toUpperCase()} ===
${description.map(line => `# ${line}`).join('\n')}
${patterns
  .concat(
    Object.entries(data)
      .filter(([_pattern, category]) => category === key)
      .map(([pattern]) => pattern),
  )
  .join('\n')}`,
  )
  .join('\n\n')}
`;
    } else {
      const result: string[] = [];
      let state: { category: string; remainingPatterns: Set<string> } | undefined = undefined;
      for (const lineRaw of contents.split('\n')) {
        const line = lineRaw.trim();
        const header = getIgnoreHeaderFromLine(line);
        if (header) {
          if (state) {
            result.splice(
              findLastIndex(result, line => !/^\s*$/.test(line)) + 1,
              0,
              ...state.remainingPatterns,
            );
          }
          state = {
            category: header,
            remainingPatterns: new Set(
              Object.entries(data)
                .filter(([_pattern, category]) => category === header)
                .map(([pattern]) => pattern),
            ),
          };
        } else if (state) {
          if (/^\s*#|^\s*$/.test(line)) {
            result.push(line);
          } else if (data[line] === state.category) {
            result.push(line);
            state.remainingPatterns.delete(line);
          }
        }
      }
      return result.join('\n');
    }
  },
});
