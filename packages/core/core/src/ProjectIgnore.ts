import path from 'path';
import fse from 'fs-extra';
import { fileTypeIgnoreFile, IgnoreCategories, IgnorePatterns } from './file-types';

export type CustomIgnoreFiles = Record<string, (patterns: IgnorePatterns) => IgnorePatterns>;

interface IgnoreCategoryDefinition {
  heading: string;
  description: string[];
  patterns: string[];
}

const GITIGNORE_FILENAME = '.gitignore';

export class ProjectIgnore {
  patterns: Record<IgnoreCategories, IgnoreCategoryDefinition> = {
    build: {
      heading: 'Build Files',
      description: [
        'Files which are the result of transforming other files in the project',
        'First item should be the path to the Typescript build output directory without any glob patterns',
      ],
      patterns: [],
    },
    cache: {
      heading: 'Cache Files',
      description: ['Generated by tools for caching'],
      patterns: [],
    },
    log: {
      heading: 'Log Files',
      description: ['Log output files intended to be read by people rather than the project'],
      patterns: [],
    },
    external: {
      heading: 'External Files',
      description: ['Files commonly created by the OS or tools not defined in this project'],
      patterns: ['.DS_Store'],
    },
    generated: {
      heading: 'Generated Files',
      description: ['Files generated by tools from the project'],
      patterns: [],
    },
    other: {
      heading: 'Other Files',
      description: ['Any other ignored files'],
      patterns: [],
    },
  };

  gitignorePath: string;

  customIgnoreFiles: CustomIgnoreFiles = {};

  constructor(public projectPath: string) {
    this.gitignorePath = path.join(projectPath, GITIGNORE_FILENAME);
  }

  // updatePatterns(
  //   patternUpdates: { [C in IgnoreCategories]?: { add: string[]; remove: string[] } },
  // ) {
  //   for (const [category, item] of Object.entries(patternUpdates)) {
  //     if (!item) continue;
  //     const ignoreCategory = this.patterns[category as IgnoreCategories];
  //     if (!ignoreCategory || !Object.prototype.hasOwnProperty.call(this.patterns, category)) {
  //       throw new Error(`Ignore file category does not exist: ${category}`);
  //     }
  //     const { patterns = [], overrides = [] } = item;
  //     ignoreCategory.patterns.push(...patterns);
  //     ignoreCategory.overrides.push(...overrides);
  //   }
  // }

  // removePatterns(ignorePatterns: IgnorePatterns) {}

  registerCustomIgnoreFiles(files: CustomIgnoreFiles) {
    for (const [key, value] of Object.entries(files)) {
      this.customIgnoreFiles[key] = value;
    }
  }

  async readOrCreateIgnoreFile(
    ignoreFilePath: string,
    ignorePatterns: IgnorePatterns,
    forceRecreate = false,
  ) {
    if (!forceRecreate && (await fse.pathExists(ignoreFilePath))) {
      return this.readIgnoreFile(ignoreFilePath);
    }
    return this.createIgnoreFile(ignoreFilePath, ignorePatterns);
  }

  async readIgnoreFile(ignoreFilePath: string) {
    const contents = await fse.readFile(ignoreFilePath, 'utf8');
    return fileTypeIgnoreFile.deserialize(contents);
  }

  async createIgnoreFile(
    ignoreFilePath: string,
    ignorePatterns: IgnorePatterns,
  ): Promise<IgnorePatterns> {
    const contents = fileTypeIgnoreFile.serialize(ignorePatterns, undefined);
    if (!contents) return {};
    await fse.writeFile(ignoreFilePath, contents);
    return fileTypeIgnoreFile.deserialize(contents);
  }
}
