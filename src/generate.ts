import path from 'path';

import fse from 'fs-extra';

interface IgnoreCategory {
  heading: string;
  description: string;
  patterns: string[];
  overrides?: string[];
}

const declareIgnoredFiles = <T extends string>(ignoredFiles: Record<T, IgnoreCategory>) =>
  ignoredFiles;

export const generateIgnored = () =>
  declareIgnoredFiles({
    build: {
      heading: 'Build Files',
      description: 'Files which are the result of transforming other files in the project',
      patterns: ['dist'],
    },
    cache: {
      heading: 'Cache Files',
      description: 'Generated by tools for caching',
      patterns: [
        'node_modules',
        '.*cache',
        '.jest',
        '.yarn',
        '*.tsbuildinfo',
        'yarn.lock',
        'package-lock.json',
      ],
      overrides: ['yarn.lock'],
    },
    log: {
      heading: 'Log Files',
      description: 'Log output files intended to be read by people rather than the project',
      patterns: ['*.log', 'coverage'],
    },
    external: {
      heading: 'External Files',
      description: 'Files commonly created by the OS or tools not defined in this project',
      patterns: ['.DS_Store'],
    },
    generated: {
      heading: 'Generated Files',
      description: 'Files generated by tools from the project',
      patterns: [
        '.gitignore',
        '.npmignore',
        '.prettierrc.js',
        '.prettierignore',
        '.eslintrc.js',
        '.eslintignore',
        'jest.config.js',
        'tsconfig.json',
        '.nvmrc',
      ],
      overrides: ['.gitignore'],
    },
    other: {
      heading: 'Other Files',
      description: 'Any other ignored files',
      patterns: [],
    },
  });

export type IgnoredFiles = ReturnType<typeof generateIgnored>;

export const getIgnoredFromGitignore = async (gitignorePath: string) => {
  const contents = await fse.readFile(gitignorePath, 'utf8');
  const ignored = {} as IgnoredFiles;
  const state: { category?: IgnoreCategory; heading?: string } = {};
  const defaultIgnoreFiles = generateIgnored();
  for (const lineRaw of contents.split('\n')) {
    const lineTrimmed = lineRaw.trim();
    const data = lineTrimmed.startsWith('#')
      ? {
          comment: lineTrimmed.substr(1).trim(),
          heading: /^#\s*===\s+(.+)\s+===$/.exec(lineTrimmed)?.[1] || undefined,
        }
      : { pattern: lineTrimmed, isNegated: lineTrimmed.startsWith('!') };

    if (data.comment) {
      if (data.heading) {
        state.category = undefined;
        state.heading = data.heading;
      } else if (!state.category && state.heading) {
        state.category = {
          heading: state.heading,
          description: data.comment,
          patterns: [],
        };
        const key = (Object.entries(defaultIgnoreFiles).find(
          ([_key, category]) => category.heading === state.heading,
        )?.[0] || 'other') as keyof IgnoredFiles;
        ignored[key] = state.category;
      }
    } else if (data.pattern && state.category) {
      if (data.isNegated) {
        if (!state.category.overrides) state.category.overrides = [];
        state.category.overrides.push(data.pattern.substr(1));
      } else {
        state.category.patterns.push(data.pattern);
      }
    }
  }

  for (const [key, category] of Object.entries(defaultIgnoreFiles)) {
    if (!(key in ignored)) {
      throw new Error('Missing gitignore category: ' + category.heading);
    }
  }
  return ignored;
};

export const generateGitignore = (
  ignoredFiles: IgnoredFiles,
) => `# DO NOT CHANGE THE STRUCTURE OF THIS FILE
# You may add or remove patterns and comments but do not change the "=== HEADING ===" comments

${Object.values(ignoredFiles)
  .map(
    ({ heading, description, patterns, overrides }) => `# === ${heading} ===
# ${description}
${patterns.join('\n')}${
      overrides ? '\n' + overrides.map(pattern => '!' + pattern).join('\n') : ''
    }`,
  )
  .join('\n\n')}
`;

export const getIgnoredOrCreate = async (gitignorePath: string) => {
  if (await fse.pathExists(gitignorePath)) return getIgnoredFromGitignore(gitignorePath);
  const ignored = generateIgnored();
  await fse.writeFile(gitignorePath, generateGitignore(ignored));
  return ignored;
};

/** Generates and writes an ignore file. Does not include overrides. */
export const generateIgnoreFile = (
  ignoredFiles: IgnoredFiles,
  excludedCategories: (keyof IgnoredFiles)[] = [],
) =>
  `# DO NOT MODIFY
# This file is generated based on .gitignore -- modify that file instead then run \`yarn install\`

${Object.entries(ignoredFiles)
  .filter(([name]) => !(excludedCategories as string[]).includes(name))
  .map(
    ([_name, { heading, description, patterns }]) => `# === ${heading} ===
# ${description}
${patterns.join('\n')}`,
  )
  .join('\n\n')}
`;

// TODO: How could we get source, test and other runtime file patterns from .gitignore?
export const generateNpmignore = (
  ignoredFiles: IgnoredFiles,
) => `# Ignore all files and make exceptions only for necessary files
**

# Include package files
!package.json
!README.md

# Include build files
${ignoredFiles.build.patterns.map(pattern => '!' + pattern).join('\n')}

# Include source files (so that source maps work)
!src

# Remove test files from source
__*__
`;

export const initProject = async (projectDir: string) => {
  const templateDir = path.join(__dirname, '..', 'templates');
  await fse.copy(templateDir, projectDir);

  const ignored = await getIgnoredOrCreate(path.join(projectDir, '.gitignore'));
  await fse.writeFile(path.join(projectDir, '.prettierignore'), generateIgnoreFile(ignored));
  await fse.writeFile(path.join(projectDir, '.eslintignore'), generateIgnoreFile(ignored));
  await fse.writeFile(path.join(projectDir, '.npmignore'), generateNpmignore(ignored));
};
