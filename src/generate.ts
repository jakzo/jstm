import path from 'path';

import fse from 'fs-extra';
import * as prettier from 'prettier';

import tsconfig from './config/tsconfig.json';
import { PackageJson, ProjectInfo } from './types';

interface IgnoreCategory {
  heading: string;
  description: string[];
  patterns: string[];
  overrides?: string[];
}

const declareIgnoredFiles = <T extends string>(ignoredFiles: Record<T, IgnoreCategory>) =>
  ignoredFiles;

export const generateIgnored = () =>
  declareIgnoredFiles({
    build: {
      heading: 'Build Files',
      description: [
        'Files which are the result of transforming other files in the project',
        'First item should be the path to the Typescript build output directory without any glob patterns',
      ],
      patterns: ['dist'],
    },
    cache: {
      heading: 'Cache Files',
      description: ['Generated by tools for caching'],
      patterns: [
        'node_modules',
        '.*cache',
        '.jest',
        '.yarn',
        '*.tsbuildinfo',
        'yarn.lock',
        'package-lock.json',
      ],
      overrides: ['yarn.lock'],
    },
    log: {
      heading: 'Log Files',
      description: ['Log output files intended to be read by people rather than the project'],
      patterns: ['*.log', 'coverage'],
    },
    external: {
      heading: 'External Files',
      description: ['Files commonly created by the OS or tools not defined in this project'],
      patterns: ['.DS_Store'],
    },
    generated: {
      heading: 'Generated Files',
      description: ['Files generated by tools from the project'],
      patterns: [
        '.gitignore',
        '.npmignore',
        '.prettierrc.js',
        '.prettierignore',
        '.eslintrc.js',
        '.eslintignore',
        'jest.config.js',
        'tsconfig.json',
        'tsconfig.eslint.json',
        '.nvmrc',
        '.vscode',
      ],
      overrides: ['.gitignore'],
    },
    other: {
      heading: 'Other Files',
      description: ['Any other ignored files'],
      patterns: [],
    },
  });

export type IgnoredFiles = ReturnType<typeof generateIgnored>;

export const getProjectInfo = (packageJson: PackageJson): ProjectInfo => {
  const { project: { srcDirs = ['./src/'], testFilePatterns = ['__*__'] } = {} } = packageJson;
  return {
    srcDirs,
    testFilePatterns,
  };
};

export const getIgnoredFromGitignore = async (gitignorePath: string) => {
  const contents = await fse.readFile(gitignorePath, 'utf8');
  const defaultIgnoreFiles = generateIgnored();
  const ignored = Object.assign(
    {},
    ...Object.entries(defaultIgnoreFiles).map(([key, category]) => ({
      [key]: {
        ...category,
        patterns: [],
      },
    })),
  ) as IgnoredFiles;
  let curCategory: IgnoreCategory = ignored.other;
  for (const lineRaw of contents.split('\n')) {
    const lineTrimmed = lineRaw.trim();
    const data = lineTrimmed.startsWith('#')
      ? {
          comment: lineTrimmed.substr(1).trim(),
          heading: /^#\s*===\s+(.+)\s+===$/.exec(lineTrimmed)?.[1] || undefined,
        }
      : { pattern: lineTrimmed, isNegated: lineTrimmed.startsWith('!') };

    if (data.comment) {
      if (data.heading) {
        curCategory =
          Object.values(ignored).find(category => category.heading === data.heading) ||
          ignored.other;
      } else {
        // TODO: Reinsert comments
      }
    } else if (data.pattern) {
      if (data.isNegated) {
        if (!curCategory.overrides) curCategory.overrides = [];
        curCategory.overrides.push(data.pattern.substr(1));
      } else {
        curCategory.patterns.push(data.pattern);
      }
    }
  }

  for (const [key, category] of Object.entries(defaultIgnoreFiles)) {
    if (!(key in ignored)) {
      throw new Error('Missing gitignore category: ' + category.heading);
    }
  }
  return ignored;
};

export const generateGitignore = (
  ignoredFiles: IgnoredFiles,
) => `# DO NOT CHANGE THE STRUCTURE OF THIS FILE
# You may add or remove patterns but do not change the "=== HEADING ===" comments

${Object.values(ignoredFiles)
  .map(
    ({ heading, description, patterns, overrides }) => `# === ${heading} ===
${description.map(line => '# ' + line).join('\n')}
${patterns.join('\n')}${
      overrides ? '\n' + overrides.map(pattern => '!' + pattern).join('\n') : ''
    }`,
  )
  .join('\n\n')}
`;

export const getIgnoredOrCreate = async (gitignorePath: string, forceRecreate = false) => {
  if (!forceRecreate && (await fse.pathExists(gitignorePath)))
    return getIgnoredFromGitignore(gitignorePath);
  const ignored = generateIgnored();
  await fse.writeFile(gitignorePath, generateGitignore(ignored));
  return ignored;
};

/** Generates and writes an ignore file. Does not include overrides. */
export const generateIgnoreFile = (
  ignoredFiles: IgnoredFiles,
  excludedCategories: (keyof IgnoredFiles)[] = [],
) =>
  `# DO NOT MODIFY
# This file is generated based on .gitignore -- modify that file instead then run \`yarn install\`

${Object.entries(ignoredFiles)
  .filter(([name]) => !(excludedCategories as string[]).includes(name))
  .map(
    ([_name, { heading, description, patterns }]) => `# === ${heading} ===
${description.map(line => '# ' + line).join('\n')}
${patterns.join('\n')}`,
  )
  .join('\n\n')}
`;

// TODO: How could we get source, test and other runtime file patterns from .gitignore?
export const generateNpmignore = (
  ignoredFiles: IgnoredFiles,
  projectInfo: ProjectInfo,
) => `# Ignore all files and make exceptions only for necessary files
**

# Include package files
!package.json
!README.md

# Include build files
${ignoredFiles.build.patterns.map(pattern => '!' + pattern).join('\n')}

# Include source files (so that source maps work)
${projectInfo.srcDirs.map(srcPath => '!' + srcPath).join('\n')}

# Remove test files from source
${projectInfo.testFilePatterns.map(testPattern => '!' + testPattern).join('\n')}
`;

export const generateBaseTsconfig = (sourceDirs: string[], ignored: IgnoredFiles) =>
  prettier.format(
    `// DO NOT MODIFY
// This file is auto-generated
${JSON.stringify({
  include: ([] as string[]).concat(...sourceDirs.map(dir => [dir, `${dir}/**/*.json`])),
  exclude: ([] as string[]).concat(...Object.values(ignored).map(category => category.patterns)),
  compilerOptions: {
    ...tsconfig.compilerOptions,
    rootDir: sourceDirs[0],
    outDir: ignored.build.patterns[0],
  },
})}`,
    { filepath: 'tsconfig.json' },
  );

export const addGeneratedScripts = async (packageJsonPath: string, packageJson: PackageJson) => {
  const generatedScripts = {
    '=== Generated Scripts (do not modify) ===': '',
    build: 'tsc',
    'build:watch': 'yarn build -w',
    lint: 'yarn lint:eslint && yarn lint:prettier',
    'lint:fix': 'yarn lint:eslint --fix && yarn lint:prettier --write',
    'lint:eslint': 'eslint --ext js,jsx,ts,tsx ./',
    'lint:prettier': 'prettier -c "./**/*{.json,.md}"',
    test: 'yarn lint && yarn test:jest',
    'test:jest': 'jest',
    '=== (end generated scripts) ===': '',
    '': '',
  };

  packageJson.scripts = Object.assign(
    generatedScripts,
    ...Object.entries(packageJson.scripts || {}).map(([key, value]) =>
      key in generatedScripts ? undefined : { [key]: value },
    ),
  ) as Record<string, string>;
  await fse.writeFile(
    packageJsonPath,
    prettier.format(JSON.stringify(packageJson), { filepath: 'package.json' }),
  );
};

export const initProject = async (projectDir: string, recreateGitignore: boolean) => {
  const packageJsonPath = path.join(projectDir, 'package.json');
  const packageJson = (await fse.readJson(packageJsonPath)) as PackageJson;
  const projectInfo = getProjectInfo(packageJson);

  const templateDir = path.join(__dirname, '..', 'templates');
  await fse.copy(templateDir, projectDir, { overwrite: true });

  const ignored = await getIgnoredOrCreate(path.join(projectDir, '.gitignore'), recreateGitignore);
  await Promise.all([
    fse.writeFile(
      path.join(projectDir, 'tsconfig.json'),
      generateBaseTsconfig(projectInfo.srcDirs, ignored),
    ),
    fse.writeFile(path.join(projectDir, '.prettierignore'), generateIgnoreFile(ignored)),
    fse.writeFile(path.join(projectDir, '.eslintignore'), generateIgnoreFile(ignored)),
    fse.writeFile(path.join(projectDir, '.npmignore'), generateNpmignore(ignored, projectInfo)),
  ]);

  await addGeneratedScripts(packageJsonPath, packageJson);
};
